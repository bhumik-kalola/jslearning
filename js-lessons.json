[
  {
    "day": 1,
    "title": "Variables & Data Types",
    "explanation": "Learn about var, let, const and JavaScript primitive types: number, string, boolean, null, undefined, symbol, bigint.",
    "code": "let x = 10;\nconst name = \"Bhumik\";\nvar oldStyle = true;\nconsole.log(typeof x, typeof name, typeof oldStyle);",
    "interviewQuestions": [
      {
        "question": "What is the difference between var, let, and const?",
        "answer": "var is function-scoped and can be redeclared, let and const are block-scoped. const cannot be reassigned."
      },
      {
        "question": "Why prefer let/const over var?",
        "answer": "let and const provide block scope and reduce bugs caused by variable hoisting and redeclaration."
      }
    ]
  },
  {
    "day": 2,
    "title": "Control Flow & Loops",
    "explanation": "Understand if-else, switch, and loops (for, while, do-while, for-of, for-in).",
    "code": "for (let i = 0; i < 3; i++) { console.log(i); }\nconst arr = [1, 2, 3];\nfor (const v of arr) console.log(v);",
    "interviewQuestions": [
      {
        "question": "When to use switch vs if-else?",
        "answer": "Use switch when checking one variable against many values; use if-else for complex conditions."
      },
      {
        "question": "What is the difference between for-in and for-of?",
        "answer": "for-in iterates over object keys; for-of iterates over iterable values like arrays."
      }
    ]
  },
  {
    "day": 3,
    "title": "Functions & Scope",
    "explanation": "Explore function declarations, expressions, arrow functions, lexical scope, and hoisting basics.",
    "code": "function add(a, b) { return a + b; }\nconst sum = (a, b) => a + b;\nconsole.log(add(2, 3), sum(4, 5));",
    "interviewQuestions": [
      {
        "question": "What is hoisting?",
        "answer": "Hoisting is JavaScript's default behavior of moving declarations to the top of the current scope."
      },
      {
        "question": "How are arrow functions different regarding 'this'?",
        "answer": "Arrow functions do not have their own 'this'; they inherit 'this' from the surrounding scope."
      }
    ]
  },
  {
    "day": 4,
    "title": "Closures & Higher-order Functions",
    "explanation": "Closures capture their lexical environment; functions can take or return functions.",
    "code": "function makeAdder(x) {\n  return function (y) { return x + y; };\n}\nconst add5 = makeAdder(5);\nconsole.log(add5(3)); // 8",
    "interviewQuestions": [
      {
        "question": "What is a closure and where is it useful?",
        "answer": "A closure is a function that remembers its outer variables even when called outside its scope; useful for data privacy."
      }
    ]
  },
  {
    "day": 5,
    "title": "Arrays & Array Methods",
    "explanation": "Learn common array operations: push, pop, shift, unshift, map, filter, reduce, find, some, every.",
    "code": "const a = [1, 2, 3];\nconsole.log(a.map(x => x * 2));\nconsole.log(a.reduce((s, v) => s + v, 0));",
    "interviewQuestions": [
      {
        "question": "When to use map vs forEach?",
        "answer": "map returns a new array; forEach executes a function without returning an array."
      },
      {
        "question": "Explain reduce with an example.",
        "answer": "reduce aggregates array values into one, e.g., summing numbers."
      }
    ]
  },
  {
    "day": 6,
    "title": "Objects & Prototypes",
    "explanation": "Understand object literals, property access, prototypal inheritance, and Object.create.",
    "code": "const obj = { name: \"A\", age: 25 };\nconsole.log(obj.name);\nconst proto = { greet() { return 'hi'; } };\nconst o = Object.create(proto);\nconsole.log(o.greet());",
    "interviewQuestions": [
      {
        "question": "What is the difference between prototype and class in JS?",
        "answer": "Classes are syntactic sugar over prototypal inheritance."
      }
    ]
  },
  {
    "day": 7,
    "title": "ES6+ Essentials",
    "explanation": "Explore destructuring, template literals, default parameters, rest/spread operators, and modules.",
    "code": "const [a, b] = [1, 2];\nconst obj = { x: 1, y: 2 };\nconst { x, y } = obj;\nconsole.log(`x=${x}, y=${y}`);",
    "interviewQuestions": [
      {
        "question": "When to use destructuring?",
        "answer": "To easily extract values from arrays or objects."
      }
    ]
  },
  {
    "day": 8,
    "title": "Strings & Regular Expressions",
    "explanation": "Learn string methods and basics of regex: test, match, replace.",
    "code": "const s = \"hello world\";\nconsole.log(s.includes(\"world\"));\nconst emailRx = /\\S+@\\S+\\.\\S+/;\nconsole.log(emailRx.test(\"a@b.com\"));",
    "interviewQuestions": [
      {
        "question": "What is the difference between test() and match()?",
        "answer": "test() returns boolean; match() returns matched string(s)."
      }
    ]
  },
  {
    "day": 9,
    "title": "Numbers, Math & Date",
    "explanation": "Understand number quirks, Math methods, and Date object basics.",
    "code": "console.log(0.1 + 0.2); // floating point issue\nconsole.log(Math.max(3, 7, 1));\nconst d = new Date();\nconsole.log(d.toISOString());",
    "interviewQuestions": [
      {
        "question": "Why does 0.1 + 0.2 !== 0.3?",
        "answer": "Due to floating point precision errors."
      }
    ]
  },
  {
    "day": 10,
    "title": "Maps, Sets & WeakMaps",
    "explanation": "Learn Map and Set for keyed collections and WeakMap/WeakSet for garbage collection-friendly references.",
    "code": "const m = new Map();\nm.set('a', 1);\nconst s = new Set([1, 2, 2]);\nconsole.log(s.has(2));",
    "interviewQuestions": [
      {
        "question": "When to use WeakMap?",
        "answer": "For keys that should not prevent garbage collection."
      }
    ]
  },
  {
    "day": 11,
    "title": "Error Handling & Debugging",
    "explanation": "Try/catch/finally, custom errors, console, and debugger statements.",
    "code": "try {\n  throw new Error(\"bad\");\n} catch (e) {\n  console.error(e.message);\n} finally {\n  console.log('cleanup');\n}",
    "interviewQuestions": [
      {
        "question": "How to handle errors in async/await?",
        "answer": "Use try/catch blocks to catch rejected promises."
      }
    ]
  },
  {
    "day": 12,
    "title": "Promises Deep Dive",
    "explanation": "Creating promises, chaining, Promise.all, Promise.race, and error flow.",
    "code": "const p = new Promise((res, rej) => setTimeout(() => res(5), 100));\np.then(v => console.log(v));",
    "interviewQuestions": [
      {
        "question": "What is the difference between Promise.all and Promise.race?",
        "answer": "Promise.all waits for all to resolve; Promise.race resolves/rejects as soon as one settles."
      }
    ]
  },
  {
    "day": 13,
    "title": "Async/Await",
    "explanation": "Syntactic sugar for promises; sequential vs parallel execution.",
    "code": "async function f() {\n  const a = await Promise.resolve(1);\n  const b = await Promise.resolve(2);\n  return a + b;\n}\nf().then(console.log);",
    "interviewQuestions": [
      {
        "question": "Why avoid using await inside forEach?",
        "answer": "forEach does not handle async/await properly; use for...of instead."
      }
    ]
  },
  {
    "day": 14,
    "title": "Event Loop & Concurrency",
    "explanation": "Call stack, task queue, microtasks (promises), timers; order of execution.",
    "code": "console.log('start');\nsetTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('promise'));\nconsole.log('end');",
    "interviewQuestions": [
      {
        "question": "What runs first: Promise.then or setTimeout?",
        "answer": "Promise.then runs first as microtask, setTimeout is macrotask."
      }
    ]
  },
  {
    "day": 15,
    "title": "`this` & Function Binding",
    "explanation": "How `this` is determined: call-time, default, arrow functions, bind/call/apply.",
    "code": "const obj = { x: 1, getX() { return this.x; } };\nconst f = obj.getX;\nconsole.log(obj.getX(), f.call(obj));",
    "interviewQuestions": [
      {
        "question": "How does bind differ from call/apply?",
        "answer": "bind returns a new function with bound this, call/apply invoke immediately."
      }
    ]
  },
  {
    "day": 16,
    "title": "Prototypes & Inheritance",
    "explanation": "Prototype chain, Object.create, function constructors, prototype methods.",
    "code": "function Person(name) { this.name = name; }\nPerson.prototype.greet = function () { return 'hi ' + this.name; };\nconst p = new Person('A'); console.log(p.greet());",
    "interviewQuestions": [
      {
        "question": "How does prototype differ from class?",
        "answer": "Classes are syntactic sugar over prototypes."
      }
    ]
  },
  {
    "day": 17,
    "title": "Classes & OOP Patterns",
    "explanation": "ES6 class syntax, extends, super, static, getters/setters.",
    "code": "class Animal {\n  constructor(name) { this.name = name; }\n  speak() { return this.name + ' speaks'; }\n}\nclass Dog extends Animal { speak() { return this.name + ' barks'; } }\nconsole.log(new Dog('Rex').speak());",
    "interviewQuestions": [
      {
        "question": "Are JS classes syntactic sugar?",
        "answer": "Yes, they simplify prototypal inheritance."
      }
    ]
  },
  {
    "day": 18,
    "title": "Modules & Packaging",
    "explanation": "ES Modules (import/export) vs CommonJS (require/module.exports); package.json basics.",
    "code": "// utils.js\nexport function add(a,b) { return a + b; }\n// main.js\nimport { add } from './utils.js';",
    "interviewQuestions": [
      {
        "question": "When use CommonJS vs ESM?",
        "answer": "CommonJS is for Node.js; ESM is standard and supported in modern environments."
      }
    ]
  },
  {
    "day": 19,
    "title": "Memory & Performance",
    "explanation": "Detecting leaks, profiling, avoiding excessive allocations, algorithmic efficiency.",
    "code": "const arr = [];\nfor (let i = 0; i < 1000; i++) { arr.push(new Array(1000).fill(i)); } // Watch memory usage",
    "interviewQuestions": [
      {
        "question": "Common causes of memory leaks in JS?",
        "answer": "Unremoved event listeners, closures holding references, global variables."
      }
    ]
  },
  {
    "day": 20,
    "title": "Functional Programming",
    "explanation": "Immutability, pure functions, map/filter/reduce, composition, currying.",
    "code": "const map = (fn, arr) => arr.map(fn);\nconst add1 = x => x + 1;\nconsole.log(map(add1, [1, 2, 3]));",
    "interviewQuestions": [
      {
        "question": "What is currying?",
        "answer": "Transforming a function with multiple arguments into a sequence of functions each with a single argument."
      }
    ]
  },
  {
    "day": 21,
    "title": "Testing & Tooling",
    "explanation": "Unit testing basics with Jest/Mocha, assertions, test structure.",
    "code": "// example.test.js (Jest)\ntest('adds 1 + 2 to equal 3', () => { expect(1 + 2).toBe(3); });",
    "interviewQuestions": [
      {
        "question": "Why write unit tests?",
        "answer": "To catch bugs early and ensure code correctness."
      }
    ]
  },
  {
    "day": 22,
    "title": "DOM Essentials",
    "explanation": "Selecting elements, event listeners, event delegation, modifying DOM safely.",
    "code": "const btn = document.querySelector('#btn');\nbtn.addEventListener('click', () => alert('clicked'));",
    "interviewQuestions": [
      {
        "question": "What is event delegation?",
        "answer": "Attaching a single event listener to a parent to manage events for multiple child elements."
      }
    ]
  },
  {
    "day": 23,
    "title": "Fetch & AJAX",
    "explanation": "fetch API, handling JSON, errors, and AbortController for cancellation.",
    "code": "async function getJson(url) {\n  const res = await fetch(url);\n  if (!res.ok) throw new Error(res.status);\n  return res.json();\n}",
    "interviewQuestions": [
      {
        "question": "When to use fetch vs axios?",
        "answer": "fetch is native and simpler; axios offers more features like interceptors and automatic JSON conversion."
      }
    ]
  },
  {
    "day": 24,
    "title": "Forms & LocalStorage",
    "explanation": "Form handling, validation, using localStorage/sessionStorage.",
    "code": "const data = { name: 'A' };\nlocalStorage.setItem('user', JSON.stringify(data));\nconsole.log(JSON.parse(localStorage.getItem('user')));",
    "interviewQuestions": [
      {
        "question": "Pros and cons of localStorage?",
        "answer": "Simple key-value storage; not secure for sensitive data, synchronous API."
      }
    ]
  },
  {
    "day": 25,
    "title": "Browser APIs & Utilities",
    "explanation": "History API, URLSearchParams, Geolocation, Performance APIs, basics of service workers.",
    "code": "const params = new URLSearchParams(window.location.search);\nconsole.log(params.get('q'));",
    "interviewQuestions": [
      {
        "question": "What is the History API used for?",
        "answer": "To manipulate browser session history without page reload."
      }
    ]
  },
  {
    "day": 26,
    "title": "Build Tools & Bundlers",
    "explanation": "npm scripts, bundlers like webpack/rollup, Babel, transpilation vs polyfills.",
    "code": "// package.json\n\"scripts\": { \"build\": \"webpack --mode production\" }",
    "interviewQuestions": [
      {
        "question": "What is tree-shaking?",
        "answer": "Removing unused code during bundling to reduce bundle size."
      }
    ]
  },
  {
    "day": 27,
    "title": "Node.js Basics",
    "explanation": "Node runtime, require/import, fs module, simple HTTP server, npm ecosystem.",
    "code": "const http = require('http');\nconst server = http.createServer((req, res) => res.end('hello'));\nserver.listen(3000);",
    "interviewQuestions": [
      {
        "question": "What is the event loop in Node.js?",
        "answer": "It handles asynchronous callbacks and non-blocking I/O operations."
      }
    ]
  },
  {
    "day": 28,
    "title": "Data Structures â€” Basics",
    "explanation": "Big-O notation, arrays, linked lists, stacks, queues; why choice matters.",
    "code": "class Stack {\n  constructor() { this._ = []; }\n  push(v) { this._.push(v); }\n  pop() { return this._.pop(); }\n}",
    "interviewQuestions": [
      {
        "question": "When use linked list over array?",
        "answer": "When frequent insertions/deletions are needed without reallocations."
      }
    ]
  },
  {
    "day": 29,
    "title": "Sorting & Searching",
    "explanation": "Bubble sort, quicksort, merge sort, binary search; algorithm efficiency.",
    "code": "function binarySearch(arr, x) {\n  let low=0, high=arr.length-1;\n  while(low <= high) {\n    let mid = Math.floor((low+high)/2);\n    if(arr[mid] === x) return mid;\n    else if(arr[mid] < x) low = mid +1;\n    else high = mid -1;\n  }\n  return -1;\n}",
    "interviewQuestions": [
      {
        "question": "What is the time complexity of quicksort?",
        "answer": "Average O(n log n), worst O(n^2)."
      }
    ]
  },
  {
    "day": 30,
    "title": "Problem Solving & Interview Prep",
    "explanation": "Common patterns like two pointers, sliding window; mock coding problems.",
    "code": "function twoSum(nums, target) {\n  const map = new Map();\n  for(let i=0; i<nums.length; i++) {\n    const diff = target - nums[i];\n    if(map.has(diff)) return [map.get(diff), i];\n    map.set(nums[i], i);\n  }\n}",
    "interviewQuestions": [
      {
        "question": "Explain two-sum problem solution.",
        "answer": "Use a hashmap to store numbers and indices, check complement to find pair in O(n)."
      }
    ]
  }
]
